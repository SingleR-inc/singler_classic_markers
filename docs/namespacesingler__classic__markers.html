<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>singler_classic_markers: singler_classic_markers Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">singler_classic_markers
   </div>
   <div id="projectbrief">Classic marker detection for SingleR</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">singler_classic_markers Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of the classic <b>SingleR</b> marker detection.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsingler__classic__markers_1_1ChooseBlockedOptions.html">ChooseBlockedOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#a5ea0e04676bd8d57ada385292c48854f">choose_blocked()</a></code>.  <a href="structsingler__classic__markers_1_1ChooseBlockedOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsingler__classic__markers_1_1ChooseOptions.html">ChooseOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#a29f3016c7e7d31e152a4419e8b5edc32">choose()</a></code>.  <a href="structsingler__classic__markers_1_1ChooseOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a29f3016c7e7d31e152a4419e8b5edc32" id="r_a29f3016c7e7d31e152a4419e8b5edc32"><td class="memTemplParams" colspan="2">template&lt;typename Stat_  = double, typename Value_ , typename Index_ , typename Label_ &gt; </td></tr>
<tr class="memitem:a29f3016c7e7d31e152a4419e8b5edc32"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::pair&lt; Index_, Stat_ &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29f3016c7e7d31e152a4419e8b5edc32">choose</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Label_ *label, const <a class="el" href="structsingler__classic__markers_1_1ChooseOptions.html">ChooseOptions</a> &amp;options)</td></tr>
<tr class="separator:a29f3016c7e7d31e152a4419e8b5edc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dd6670d70dbc7a563785a95282d93b" id="r_a02dd6670d70dbc7a563785a95282d93b"><td class="memTemplParams" colspan="2">template&lt;typename Stat_  = double, typename Value_ , typename Index_ , typename Label_ &gt; </td></tr>
<tr class="memitem:a02dd6670d70dbc7a563785a95282d93b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a02dd6670d70dbc7a563785a95282d93b">choose_index</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Label_ *label, const <a class="el" href="structsingler__classic__markers_1_1ChooseOptions.html">ChooseOptions</a> &amp;options)</td></tr>
<tr class="separator:a02dd6670d70dbc7a563785a95282d93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea0e04676bd8d57ada385292c48854f" id="r_a5ea0e04676bd8d57ada385292c48854f"><td class="memTemplParams" colspan="2">template&lt;typename Stat_  = double, typename Value_ , typename Index_ , typename Label_ , typename Block_ &gt; </td></tr>
<tr class="memitem:a5ea0e04676bd8d57ada385292c48854f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::pair&lt; Index_, Stat_ &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5ea0e04676bd8d57ada385292c48854f">choose_blocked</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Label_ *label, const Block_ *block, const <a class="el" href="structsingler__classic__markers_1_1ChooseBlockedOptions.html">ChooseBlockedOptions</a> &amp;options)</td></tr>
<tr class="separator:a5ea0e04676bd8d57ada385292c48854f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2527ca3c9a462e8ac4640aa00890b8" id="r_a7b2527ca3c9a462e8ac4640aa00890b8"><td class="memTemplParams" colspan="2">template&lt;typename Stat_  = double, typename Value_ , typename Index_ , typename Label_ , typename Block_ &gt; </td></tr>
<tr class="memitem:a7b2527ca3c9a462e8ac4640aa00890b8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b2527ca3c9a462e8ac4640aa00890b8">choose_blocked_index</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Label_ *label, const Block_ *block, const <a class="el" href="structsingler__classic__markers_1_1ChooseBlockedOptions.html">ChooseBlockedOptions</a> &amp;options)</td></tr>
<tr class="separator:a7b2527ca3c9a462e8ac4640aa00890b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860e14fb031f5e489d1da24c65c02f09" id="r_a860e14fb031f5e489d1da24c65c02f09"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a860e14fb031f5e489d1da24c65c02f09">default_number</a> (std::size_t num_labels)</td></tr>
<tr class="separator:a860e14fb031f5e489d1da24c65c02f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the classic <b>SingleR</b> marker detection. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a29f3016c7e7d31e152a4419e8b5edc32" name="a29f3016c7e7d31e152a4419e8b5edc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f3016c7e7d31e152a4419e8b5edc32">&#9670;&#160;</a></span>choose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_  = double, typename Value_ , typename Index_ , typename Label_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::vector&lt; std::pair&lt; Index_, Stat_ &gt; &gt; &gt; &gt; singler_classic_markers::choose </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Label_ *</td>          <td class="paramname"><span class="paramname"><em>label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsingler__classic__markers_1_1ChooseOptions.html">ChooseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements the classic <b>SingleR</b> method for choosing markers from (typically bulk) reference datasets. We assume that we have a matrix of representative expression profiles for each label, typically computed by averaging across all reference profiles for that label. For the comparison between labels \(A\) and \(B\), we define the marker set as the top genes with the largest positive differences in \(A\)'s profile over \(B\). This difference can be interpreted as the log-fold change if the input matrix contains log-expression values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat_</td><td>Floating-point type of the differences between medians. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type of matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of matrix row/column indices. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type of the label identity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Matrix containing a reference dataset. Each column should correspond to a sample while each row should represent a gene. </td></tr>
    <tr><td class="paramname">label</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>. Each value of the array should specify the label for the corresponding column. Values should lie in \([0, L)\) for \(L\) unique labels. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Top markers for each pairwise comparison between labels. Given the <code>output</code>, the vector at <code>output[i][j]</code> contains the top markers for label <code>i</code> over label <code>j</code>. Each marker is represented by a pair containing the row index in <code>matrix</code> and the difference between medians. Each innermost vector is sorted by the differences between medians. All differences are guaranteed to be positive. </dd></dl>

</div>
</div>
<a id="a5ea0e04676bd8d57ada385292c48854f" name="a5ea0e04676bd8d57ada385292c48854f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea0e04676bd8d57ada385292c48854f">&#9670;&#160;</a></span>choose_blocked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_  = double, typename Value_ , typename Index_ , typename Label_ , typename Block_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::vector&lt; std::pair&lt; Index_, Stat_ &gt; &gt; &gt; &gt; singler_classic_markers::choose_blocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Label_ *</td>          <td class="paramname"><span class="paramname"><em>label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block_ *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsingler__classic__markers_1_1ChooseBlockedOptions.html">ChooseBlockedOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of <code><a class="el" href="#a29f3016c7e7d31e152a4419e8b5edc32">choose()</a></code> that handles multiple blocks (e.g., batch effects) in the reference dataset. Differences between medians are computed within each block and then combined across blocks to obtain a single statistic per gene in each pairwise comparison. The default method is to compute the mean of the per-block differences, but we can also compute the minimum for greater stringency.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat_</td><td>Floating-point type of the differences between medians. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type of matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of matrix row/column indices. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type of the label identity. </td></tr>
    <tr><td class="paramname">Block_</td><td>Integer type of the block assignment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Matrix containing a reference dataset. Each column should correspond to a sample while each row should represent a gene. </td></tr>
    <tr><td class="paramname">label</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>. Each value of the array should specify the label for the corresponding column. Values should lie in \([0, L)\) for \(L\) unique labels. </td></tr>
    <tr><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>. Each value of the array should specify the block for the corresponding column. Values should lie in \([0, B)\) for \(B\) unique blocks. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Top markers for each pairwise comparison between labels. This is equivalent in structure to the return value of <code><a class="el" href="#a29f3016c7e7d31e152a4419e8b5edc32">choose()</a></code>, except that the combined difference between medians is reported for each marker. </dd></dl>

</div>
</div>
<a id="a7b2527ca3c9a462e8ac4640aa00890b8" name="a7b2527ca3c9a462e8ac4640aa00890b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2527ca3c9a462e8ac4640aa00890b8">&#9670;&#160;</a></span>choose_blocked_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_  = double, typename Value_ , typename Index_ , typename Label_ , typename Block_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt; singler_classic_markers::choose_blocked_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Label_ *</td>          <td class="paramname"><span class="paramname"><em>label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block_ *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsingler__classic__markers_1_1ChooseBlockedOptions.html">ChooseBlockedOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of <code><a class="el" href="#a5ea0e04676bd8d57ada385292c48854f">choose_blocked()</a></code> that only reports the indices of the top markers for each pairwise comparison. This can be used directly in <b>singlepp</b> functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat_</td><td>Floating-point type of the differences between medians. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type of matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of matrix row/column indices. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type of the label identity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Matrix containing a reference dataset. Each column should correspond to a sample while each row should represent a gene. </td></tr>
    <tr><td class="paramname">label</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>. Each value of the array should specify the label for the corresponding column. Values should lie in \([0, L)\) for \(L\) unique labels. </td></tr>
    <tr><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>. Each value of the array should specify the block for the corresponding column. Values should lie in \([0, B)\) for \(B\) unique blocks. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Top markers for each pairwise comparison between labels. This is the same as the output for <code><a class="el" href="#a5ea0e04676bd8d57ada385292c48854f">choose_blocked()</a></code> except that only the row index is reported in the innermost vector. </dd></dl>

</div>
</div>
<a id="a02dd6670d70dbc7a563785a95282d93b" name="a02dd6670d70dbc7a563785a95282d93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02dd6670d70dbc7a563785a95282d93b">&#9670;&#160;</a></span>choose_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_  = double, typename Value_ , typename Index_ , typename Label_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt; singler_classic_markers::choose_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Label_ *</td>          <td class="paramname"><span class="paramname"><em>label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsingler__classic__markers_1_1ChooseOptions.html">ChooseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of <code><a class="el" href="#a29f3016c7e7d31e152a4419e8b5edc32">choose()</a></code> that only reports the indices of the top markers for each pairwise comparison. This can be used directly in <b>singlepp</b> functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat_</td><td>Floating-point type of the differences between medians. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type of matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of matrix row/column indices. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type of the label identity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Matrix containing a reference dataset. Each column should correspond to a sample while each row should represent a gene. </td></tr>
    <tr><td class="paramname">label</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>. Each value of the array should specify the label for the corresponding column. Values should lie in \([0, L)\) for \(L\) unique labels. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Top markers for each pairwise comparison between labels. This is the same as the output for <code><a class="el" href="#a29f3016c7e7d31e152a4419e8b5edc32">choose()</a></code> except that only the row index is reported in the innermost vector. </dd></dl>

</div>
</div>
<a id="a860e14fb031f5e489d1da24c65c02f09" name="a860e14fb031f5e489d1da24c65c02f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860e14fb031f5e489d1da24c65c02f09">&#9670;&#160;</a></span>default_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t singler_classic_markers::default_number </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_labels</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default number of markers in <code><a class="el" href="#a29f3016c7e7d31e152a4419e8b5edc32">choose()</a></code> and <code><a class="el" href="#a5ea0e04676bd8d57ada385292c48854f">choose_blocked()</a></code>.</p>
<p>The exact expression is defined as \(500 (\frac{2}{3})^{\log_2{L}}\) for \(L\) labels, which steadily decreases the markers per comparison as the number of labels increases. This aims to avoid an excessive number of features when dealing with references with many labels. At \(L=0\), the number of markers is set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_labels</td><td>Number of labels in the reference(s).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An appropriate number of markers for each pairwise comparison. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
